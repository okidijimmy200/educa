Course Introduction:
In this chapter, you will learn how to:
• Create fixtures for your models
• Use model inheritance
• Create custom model fields
• Use class-based views and mixins
• Build formsets
• Manage groups and permissions
• Create a CMS

Lecture 1:
Building the course models
--be divided into a configurable number of modules, and each module will contain
a configurable number of contents. The contents will be of various types: text, file,
image, or video

Data structure of course;
Subject 1
Course 1
Module 1
Content 1 (image)
Content 2 (text)
Module 2
Content 3 (text)
Content 4 (file)
Content 5 (video)

--Each course is divided into several modules. Therefore, the Module model contains
a ForeignKey field that points to the Course model.

***********python manage.py makemigrations**********8

******python manage.py migrate*******88

Registering the models in the administration site:

--register courses in the administration

Using fixtures to provide initial data for models:
--Sometimes, you might want to prepopulate your database with hardcoded data.
This is useful for automatically including initial data in the project setup, instead of
having to add it manually. Django comes with a simple way to load and dump data
from the database into files that are called fixtures.

--we will create fixture to include several initial subject offers.

*******python manage.py createsuperuser*********8

*******python manage.py runserver*********8


Run the following command from the shell:
****************python manage.py dumpdata courses --indent=2**********

--The dumpdata command dumps data from the database into the standard
output, serialized in JSON format by default. The resulting data structure
includes information about the model and its fields for Django to be able
to load it into the database

--You can limit the output to the models of an application by providing the application
names to the command, or specifying single models for outputting data using the
app.Model format

--You can also specify the format using the --format flag. By
default, dumpdata outputs the serialized data to the standard output.

--Save this dump to a fixtures file in a new fixtures/ directory in the courses
application using the following commands:

***********mkdir courses/fixtures************8
************python manage.py dumpdata courses --indent=2 --output=courses/fixtures/subjects.json*******88

--Run the development server and use the administration site to remove the subjects
you created. Then, load the fixture into the database using the following command

******python manage.py loaddata subjects.json************

--All Subject objects included in the fixture are loaded into the database.

NB:
Fixtures are not only useful for setting up initial data, but also for
providing sample data for your application or data required for
your tests.


Lecture 2:
Creating models for diverse content::
--You plan to add different types of content to the course modules, such as text,
images, files, and videos. Therefore, you need a versatile data model that allows
you to store diverse content

--You are going to create a Content model that represents the
modules' contents, and define a generic relation to associate any kind of content.
--You are going to use a different model for each type of content. Your content models
will have some common fields, but they will differ in the actual data they can store.

Using model inheritance:;
--Django supports model inheritance. It works in a similar way to standard class
inheritance in Python.

it works in the 3 ways;
• Abstract models: Useful when you want to put some common information
into several models.
• Multi-table model inheritance: Applicable when each model in the
hierarchy is considered a complete model by itself.
• Proxy models: Useful when you need to change the behavior of a model,
for example, by including additional methods, changing the default manager,
or using different meta options.

Abstract models::
--An abstract model is a base class in which you define fields you want to include
in all child models. Django doesn't create any database tables for abstract models.
A database table is created for each child model, including the fields inherited from
the abstract class and the ones defined in the child model.

--To mark a model as abstract, you need to include abstract=True in its Meta class.
--To create child models, you just need to subclass the abstract model.

Multi-table model inheritance::
--In multi-table inheritance, each model corresponds to a database table. Django
creates a OneToOneField field for the relationship between the child model and its
parent model. To use multi-table inheritance, you have to subclass an existing model.

Proxy models::
--A proxy model changes the behavior of a model. Both models operate on the
database table of the original model. To create a proxy model, add proxy=True to
the Meta class of the model
--here both parent and child models operate on the same database table created.


